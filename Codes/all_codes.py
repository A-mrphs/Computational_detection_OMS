# -*- coding: utf-8 -*-
"""All_codes.ipynb

Automatically generated by Colaboratory.

"""

# Necessary imports
import pandas as pd
import sklearn as sk
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import confusion_matrix,f1_score,precision_score,accuracy_score,roc_curve,auc
from sklearn.feature_selection import SelectFromModel
from sklearn.model_selection import cross_val_score, GridSearchCV
from sklearn.inspection import permutation_importance
from sklearn.model_selection import cross_val_predict
from sklearn.metrics import recall_score, precision_recall_curve
from sklearn.metrics import mean_squared_error as MSE
from sklearn.metrics import roc_auc_score
import seaborn as sns
import matplotlib.pyplot as plt
import xgboost as xgb
from xgboost import plot_importance
import warnings
from xgboost.sklearn import XGBClassifier
from sklearn import metrics
from google.colab import files

# Load dataset
df1 = pd.read_csv('/content/sample_data/noncomposition_data_9_24.csv', low_memory=False, na_values='NULL')
df1=df1.drop(['filename','Unnamed: 0'], axis=1)
df1['metal_ElectronAffinity']

# df1['Has_OMS']=='Yes'

df1 = df1.fillna(value=0.00)
df1.isnull().values.any()

# Create training and testing sets
Train = df1.sample(frac=0.7,random_state=1)
Test = df1[~df1.index.isin(Train.index)]
Train.max()
Test.info()

# Delete label from training set
trainlist = list(Train)
for i in range(0,len(trainlist)):
    if trainlist[i]=='Has_OMS':
        k=i

del trainlist[k]

X_train = Train.loc[:,trainlist]
y_train = Train.loc[:,'Has_OMS']
X_test = Test.loc[:,trainlist]
y_test = Test.loc[:,'Has_OMS']
len(X_train)

"""# Training and parameter tuning of Random Forest Classifier"""

# Grid search for best parameters
param_grid = {
  'max_depth':np.arange(10, 30),
  'n_estimators':np.arange(150, 200),
  'min_samples_split':np.arange(1, 5),
  'min_samples_leaf':np.arange(1, 5),
}

rfc = RandomForestClassifier()
GS = GridSearchCV(rfc,param_grid,cv=10,n_jobs=-1)
GS.fit(X_train,y_train)

print(GS.best_params_)
print(GS.best_score_)

df = pd.read_csv("../input/core-mof/noncomposition_data_9_24.csv",index_col = 'filename')
del df['Unnamed: 0']

def MaxMinNormalization(x):
    return (x - np.min(x)) / (np.max(x) - np.min(x))
    
df = MaxMinNormalization(df)
df = df.fillna(value=0.00)
Train = df.sample(frac=0.7)
Test = df[~df.index.isin(Train.index)]
# list(Train)

# Define training and testing sets
X_train = Train.loc[:,['IonizationEnergy','metal_number']]
y_train = Train.loc[:,'Has_OMS']
X_test = Test.loc[:,['IonizationEnergy','metal_number']]
y_test = Test.loc[:,'Has_OMS']

# Grid search & Best paramters / scores
param_grid = {
  'n_estimator':np.arange(150, 200),
  'max_depth':np.arange(20, 30),
  'min_samples_split':np.arange(2, 5),
  'min_samples_leaf':np.arange(1, 4),
}

rfc = RandomForestClassifier()
GS = GridSearchCV(rfc,param_grid,cv=10,n_jobs=-1)
GS.fit(X_train,y_train)

print(GS.best_params_)
print(GS.best_score_)

# Training using optimized parameters
rf_clf_final = RandomForestClassifier(n_estimators=174,
                                      max_depth=22,
                                      min_samples_split=2,
                                      min_samples_leaf=1)

# Prediction of test values
rf_clf_final.fit(X_train,y_train)
y_pre = rf_clf_final.predict(X_test)

# Generation of confusion matrix
C = confusion_matrix(y_test,y_pre)
df=pd.DataFrame(C,index=["Positive", "Negative"],columns=["Positive", "Negative"])
sns.heatmap(df,cmap='Blues')

# Evaluations of accuracy
print(metrics.classification_report(y_test,y_pre))
print(f1_score(y_test,y_pre))
print(MSE(y_test,y_pre))

y_scores = cross_val_predict(rf_clf_final, X_train, y_train, cv=3)
print(roc_auc_score(y_train, y_scores))

# Plot precision_recall vs. threshold
def plot_precision_recall_vs_threshold(precisions, recalls, thresholds):
    plt.plot(thresholds, precisions[:-1], "b--", label="Precision")
    plt.plot(thresholds, recalls[:-1], "g-", label="Recall")
    plt.xlabel("Threshold")
    plt.legend(loc="upper left")
    plt.ylim([0, 1])

y_scores = cross_val_predict(rf_clf_final, X_train, y_train, cv=3)
precisions, recalls, thresholds = precision_recall_curve(y_train, y_scores)
plot_precision_recall_vs_threshold(precisions, recalls, thresholds)
plt.show()

# Plot decision regions
X = X_train.to_numpy(dtype=int)
y = y_train.to_numpy(dtype=int)
fig,ax = plt.subplots(figsize=(10,8))
plot_decision_regions(X,y,clf=rf_clf_final,ax=ax)
plt.show()

"""# Feature importance analysis of Random Forest Classifier"""

# Get feature importance list from model
importance = RF.feature_importances_
RF_imp = pd.Series(importance, index = trainlist).sort_values(ascending = False)
RF_Imp=RF_imp[0:15]
impdf = pd.DataFrame(RF_Imp, columns = ['Importance'])

# Plot feature importance 

plt.figure(figsize=[6,4], dpi=150)
sns.set_style('whitegrid')
impdf_imp=['Fraction of in d orbitals','Ionization energy','Atomic mass','Electronegativity','Volume','Fraction of O atoms',
'Electron fraction in p orbitals','Boiling point','Density','Nonmetal electronegativity','Pore Limiting Diameter',
'Electron affinity','Atomic radius','Number of metal atoms','Void fraction']
plot = sns.barplot(x = impdf['Importance'], y = impdf_imp, data = impdf, palette = 'Blues_r', edgecolor = '.2')
# plot.set_xticklabels(plot.get_xticklabels(), rotation=45, horizontalalignment='right')
plot.set_title('RF feature importance score - Impurity')
# plt.show()
# plt.savefig('RFimp_imp.png', dpi=150, bbox_inches='tight', pad_inches=0.2)

# Permutation importance (not displayed in main text)
per_imp = permutation_importance(RF.fit(X_train, y_train), X_test, y_test, n_repeats=30)
per_Imp=pd.Series(per_imp.importances_mean, index=trainlist).sort_values(ascending=False)
per_Imp_top=pd.DataFrame(per_Imp[0:10], columns=['Importance'])
per_Imp_top['Importance']

per_Imp=pd.Series(per_imp.importances_mean, index=trainlist).sort_values(ascending=False)
per_Imp_top=pd.DataFrame(per_Imp[0:10], columns=['Importance'])
per_Imp_top['Importance']

# Plot permutation importance

plt.figure(figsize=[6,4], dpi=150)
sns.set_style('whitegrid')
perm_imp=['Avg. ionization energy','Fraction of electrons in d orbitals','Fraction of metal atoms','Avg. metal melting point',
'Metal electronegativity','Avg. boiling point','Avg. nonmetal electron affinity','Avg. electron affinity', 'Avg. metal electron affinity',
'Avg. nonmetal ionization energy']
plot = sns.barplot(x='Importance', y=perm_imp, data=per_Imp_top, palette = 'Blues_r', edgecolor = '.2')
# plot.set_xticklabels(plot.get_xticklabels(), rotation=45, horizontalalignment='right')
plt.title('RF importance score - Permutation')
# plt.show()
plt.savefig('RFimp_per.png', dpi=450, bbox_inches='tight', pad_inches=0.2)
# files.download('RFimp_per.png')

"""# Training and parameter tuning of XGBoost classifier"""

# Define normalization function
def MaxMinNormalization(x):
    return (x - np.min(x)) / (np.max(x) - np.min(x))

# Load dataset
df = pd.read_csv("../input/core-mof/noncomposition_data_9_24.csv",index_col = 'filename')
del df['Unnamed: 0']

# Normalization
df = MaxMinNormalization(df)
df = df.fillna(value=0.00)
df.head()

# Generate training and testing sets
Train = df.sample(frac=0.7)
Test = df[~df.index.isin(Train.index)]
trainlist = list(Train)
#del trainlist[0]
del trainlist[9]

#trainlist
X_train = Train.loc[:,trainlist]
y_train = Train.loc[:,'Has_OMS']
X_test = Test.loc[:,trainlist]
y_test = Test.loc[:,'Has_OMS']

# Grid search & Best paramters / scores
param_grid = {
  'max_depth':np.arange(3, 10),
  'eta':np.arange(0.01, 0.5),
  'subsample':np.arange(0.5, 1),
  'colsample_bytree':np.arange(0.5, 1),
}

rfc = xgb.XGBClassifier()
GS = GridSearchCV(rfc,param_grid,cv=10,n_jobs=-1)
GS.fit(X_train,y_train)

print(GS.best_params_)
print(GS.best_score_)

# Train model from best parameters
xgb = xgb.XGBClassifier('colsample_bytree': 0.5, 
                        'eta': 0.01, 
                        'max_depth': 9, 
                        'subsample': 0.5)
xgb.fit(X_train,y_train)
y_pre = xgb.predict(X_test)

# Plot confusion matrix
C = confusion_matrix(y_test,y_pre)
df=pd.DataFrame(C,index=["Positive", "Negative"],columns=["Positive", "Negative"])
import seaborn as sns
sns.heatmap(df,cmap='Blues')

# Print accuracy evaluations
print(metrics.classification_report(y_test,y_pre))
print(f1_score(y_test,y_pre))
print(MSE(y_test,y_pre))

# Plot precision_recall vs. threshold
def plot_precision_recall_vs_threshold(precisions, recalls, thresholds):
    plt.plot(thresholds, precisions[:-1], "b--", label="Precision")
    plt.plot(thresholds, recalls[:-1], "g-", label="Recall")
    plt.xlabel("Threshold")
    plt.legend(loc="upper left")
    plt.ylim([0, 1])

y_scores = cross_val_predict(xgb, X_train, y_train, cv=3)
precisions, recalls, thresholds = precision_recall_curve(y_train, y_scores)
plot_precision_recall_vs_threshold(precisions, recalls, thresholds)
plt.show()

# Get XGBoost importance scores
xgimp=pd.Series(xg.feature_importances_, index = trainlist).sort_values(ascending = False)
xgImp=pd.DataFrame(xgimp[0:10], columns=['Importance'])
xgImp
# xg_imp=pd.Series(xg.feature_importances_, index = trainlist).sort_values(ascending = False)
# xg_Imp=pd.DataFrame(xgimp[0:10], columns=['Importance'])
# xg_Imp

"""# Plot XGBoost feature importance """

plt.figure(figsize=[6,4], dpi=150)
sns.set_style('whitegrid')
xgimp=['Avg. metal electron affinity','Avg. boiling point','Fraction of electrons in d orbitals','Fraction of electrons in f orbitals','Avg. ionization energy','Fraction of metal atoms',
      'Avg. metal melting point','Avg. nonmetal atomic mass','Avg. nonmetal electronegativity','Density']
plot = sns.barplot(x = xgImp['Importance'], y =xgimp , data = xgImp, palette = 'Blues_r', edgecolor = '.2')
# plot.set_xticklabels(plot.get_xticklabels(), rotation=45, horizontalalignment='right')
plot.set_title('XGBoost feature importance score')
# plt.show()
plt.savefig('XGBimp_.png', dpi=150, bbox_inches='tight', pad_inches=0.2)
# files.download('XGBimp_.png')

# dfr = pd.read_csv('/content/sample_data/wavg_data.csv', low_memory=False, na_values='NULL')
# dfr=dfr.drop(['filename','Unnamed: 0'], axis=1)
# dfr.head()

"""# Generating feature-specific comparison plots between MOFs with and without OMS"""

# Lable correction
def replace(x):
  if x:
    return 'With OMS'
  else:
    return 'Without OMS'

data=pd.DataFrame(df1['Has_OMS']).applymap(replace)
df2=pd.concat([df1.drop(['Has_OMS'],axis=1),data],axis=1)
df2['Has_OMS']

# Figure generation
plt.figure(figsize=[6,4], dpi=150)
sns.set_style('whitegrid')
facet = sns.FacetGrid(df2, hue="Has_OMS",aspect=4)
facet.map(sns.kdeplot,'EC_d',shade= True,)
facet.set(xlim=(0, df2['EC_d'].max()))
facet.add_legend(title='')
df_p=df2[df2['Has_OMS']=='With OMS']
df_n=df2[df2['Has_OMS']=='Without OMS']
plt.axvline(x=df_p['EC_d'].mean(), color='orange',linestyle='--')
plt.axvline(x=df_n['EC_d'].mean(), color='blue',linestyle='--')
ax=plt.gca()
ax.set_xticks([0,df_n['EC_d'].mean(),df_p['EC_d'].mean(),2,4,6])
ax.set_xlim([0,6])
plt.xlabel('Average number of electrons in d orbitals')
# plt.savefig('ecd.png', dpi=150, bbox_inches='tight', pad_inches=0.2)
# files.download('ecd.png')

plt.figure(figsize=[6,4], dpi=150)
sns.set_style('whitegrid')
facet = sns.FacetGrid(df2, hue="Has_OMS",aspect=4)
facet.map(sns.kdeplot,'IonizationEnergy',shade= True,)
facet.set(xlim=(0, df2['IonizationEnergy'].max()))
facet.add_legend(title='')
plt.axvline(x=df_p['IonizationEnergy'].mean(), color='orange',linestyle='--')
plt.axvline(x=df_n['IonizationEnergy'].mean(), color='blue',linestyle='--')
ax=plt.gca()
ax.set_xticks([10,df_n['IonizationEnergy'].mean(),df_p['IonizationEnergy'].mean(),12,14])
plt.xticks(rotation=45)
ax.set_xlim([10,14])
plt.xlabel('Average ionization energy (eV)')
plt.savefig('ie.png', dpi=150, bbox_inches='tight', pad_inches=0.2)
files.download('ie.png')

dfr=pd.read_csv('/content/sample_data/wavg_data.csv')
datar=pd.DataFrame(dfr['Has_OMS']).applymap(replace)
dfrr=pd.concat([dfr.drop(['Has_OMS'],axis=1),data],axis=1)
dfrr_p=dfrr[dfrr['Has_OMS']=='With OMS']
dfrr_n=dfrr[dfrr['Has_OMS']=='Without OMS']
plt.figure(figsize=[6,4], dpi=150)
sns.set_style('whitegrid')
facet = sns.FacetGrid(dfrr, hue="Has_OMS",aspect=4)
facet.map(sns.kdeplot,'metal_fraction',shade= True,)
facet.set(xlim=(0, dfrr['metal_fraction'].max()))
facet.add_legend(title='')
plt.axvline(x=dfrr_p['metal_fraction'].mean(), color='orange',linestyle='--')
plt.axvline(x=dfrr_n['metal_fraction'].mean(), color='blue',linestyle='--')
ax=plt.gca()
ax.set_xticks([0,dfrr_p['metal_fraction'].mean(),dfrr_n['metal_fraction'].mean(),0.1,0.2,0.3])
ax.set_xlim([0,0.3])
plt.xticks(rotation=45)
plt.xlabel('Fraction of metal atoms')
# plt.savefig('mf.png', dpi=150, bbox_inches='tight', pad_inches=0.2)
# files.download('mf.png')

plt.figure(figsize=[6,4], dpi=150)
sns.set_style('whitegrid')
facet = sns.FacetGrid(df2, hue="Has_OMS",aspect=4)
facet.map(sns.kdeplot,'BoilingPoint',shade= True,)
facet.set(xlim=(0, df2['BoilingPoint'].max()))
facet.add_legend(title='')
plt.axvline(x=df_p['BoilingPoint'].mean(), color='orange',linestyle='--')
plt.axvline(x=df_n['BoilingPoint'].mean(), color='blue',linestyle='--')
ax=plt.gca()
ax.set_xticks([0,500,1000,1500,df_n['BoilingPoint'].mean(),df_p['BoilingPoint'].mean(),2000,2500,3000,3500])
plt.xticks(rotation=45)
# ax.set_xlim([10,14])
plt.xlabel('Average boiling point (K)')
plt.savefig('bp.png', dpi=150, bbox_inches='tight', pad_inches=0.2)
files.download('bp.png')

plt.figure(figsize=[6,4], dpi=150)
sns.set_style('whitegrid')
facet = sns.FacetGrid(df2, hue="Has_OMS",aspect=4)
facet.map(sns.kdeplot,'metal_ElectronAffinity',shade= True,)
facet.set(xlim=(0, df2['metal_ElectronAffinity'].max()))
facet.add_legend(title='')
plt.axvline(x=df_p['metal_ElectronAffinity'].mean(), color='orange',linestyle='--')
plt.axvline(x=df_n['metal_ElectronAffinity'].mean(), color='blue',linestyle='--')
ax=plt.gca()
ax.set_xticks([0,0.25,df_n['metal_ElectronAffinity'].mean(),df_p['metal_ElectronAffinity'].mean(),0.5,0.75,1.00,1.25,1.50,1.75])
plt.xticks(rotation=45)
ax.set_xlim([0,1.75])
plt.xlabel('Average metal electron affinity (eV)')
plt.savefig('me.png', dpi=150, bbox_inches='tight', pad_inches=0.2)
files.download('me.png')

"""Move some part of main text to supplementary information

Put discussion on permutation to supplementary information
"""
